- Collision = when two keys return the same memory adress: look at the multiple ways to solve this later

- Collission resolution = how to handel colissions

- colission resolution java hashmap = iterates key's hashcode() and .equals() with every value, if equal is found, the new value replaces the old one, else new entry will be generated inside the map

- Hash table speed is faster because index doesn't have to be iterated but goes straight to the index which changes
time complexity from O(n) to O(1)

- Amortized analysis = Calculating the average worst case complexity of an algorithm over a sequance of inputs

- hashset = collection with unique values, is unordered, is not thread safe/async, has Remove Add and Contains, no key available can be iterated trough convert .toArray(), or using Iterator<string> i = names.iterator()
then using i.next() callable trough  HashSet<String> names = new HashSet<String>(); names.add("text"); while(i.hasNext()){ System.out.println(i.next());}

- hashmap = unordered dictionary with key value pair, is not thread safe/async, it can have one null as key value, and multiple null values, has a Put Get Remove and Replace command, can be used as : HashMap<Integer,String> names = new HashMap<Integer,String>(); names.put(1, "test1"); names.forEach((key, value)-> System.out.println(key + " = " + value));

- hashtable = same as hashmap but doesn't allow null values or keys and is thread-safe/synchronous

- ∈ = left is element of right

- [i+1,n] = Range starting from i+1 till n

- ∑(i+1 n)  = Iteration starting from i+1 till n

- O(∑ i=0 n−1 (∑ j=i+1 n (j−i)))=O(∑ i=0 n−1 2 (1+n−i)(n−i))=O(n^3) // find out where third iteration comes from

- space complexity is the data added or manipulated inside the method, the biggest value is te space complexity e.g: a for loop which uses an array would result in O(n)

- O(1) The running time of a constant-time algorithm does not depend on the input size. A typical constant-time algorithm is a direct formula that calculates the answer.

- O(logn) A logarithmic algorithm often halves the input size at each step. The running time of such an algorithm is logarithmic, because log2 n equals the number of times n must be divided by 2 to get 1.

- O(√n) A square root algorithm is slower than O(logn) but faster than O(n). A special property of square roots is that √n = n/√ n, so the square root √n
lies, in some sense, in the middle of the input.

- O(n) A linear algorithm goes through the input a constant number of times. This is often the best possible time complexity, because it is usually necessary to access each input element at least once before reporting the answer.

- O(nlogn) This time complexity often indicates that the algorithm sorts the input, because the time complexity of efficient sorting algorithms is O(nlogn).
Another possibility is that the algorithm uses a data structure where each operation takes O(logn) time.

- O(n2) A quadratic algorithm often contains two nested loops. It is possible to go through all pairs of the input elements in O(n2) time.

- O(n3) A cubic algorithm often contains three nested loops. It is possible to go through all triplets of the input elements in O(n3) time.

- O(2n) This time complexity often indicates that the algorithm iterates through all subsets of the input elements. For example, the subsets of {1,2,3} are ;,
{1}, {2}, {3}, {1,2}, {1,3}, {2,3} and {1,2,3}.

- O(n!) This time complexity often indicates that the algorithm iterates through
all permutations of the input elements. For example, the permutations of
{1,2,3} are (1,2,3), (1,3,2), (2,1,3), (2,3,1), (3,1,2) and (3,2,1).

- An algorithm is polynomial if its time complexity is at most O(n^k) where k is
a constant. All the above time complexities except O(2^n) and O(n!) are polynomial.
In practice, the constant k is usually small, and therefore a polynomial time

- there are many important
problems for which no polynomial algorithm is known, i.e., nobody knows how to
solve them efficiently. NP-hard problems are an important set of problems, for
which no polynomial algorithm is known1

 - time/space complexity chart https://www.bigocheatsheet.com/, hashset is constant all over;